Студент: Валуев Фаддей Денисович
ISU: 408352

# Задача 2025. Стенка на стенку.
## Условие

Бокс, каратэ, самбо… Классические боевые единоборства пресытили аудиторию. Поэтому известный спортивный канал запускает новый формат соревнований, основанный на традиционной русской забаве — боях стенка на стенку. В соревновании могут участвовать от двух до k команд, каждая из которых будет соперничать с остальными. Всего в соревновании примут участие n бойцов. Перед началом боя они должны разделиться на команды, каждый боец должен войти ровно в одну команду. За время боя два бойца сразятся, если они состоят в разных командах. Организаторы считают, что популярность соревнований будет тем выше, чем больше будет количество схваток между бойцами. Помогите распределить бойцов по командам так, чтобы максимизировать количество схваток между бойцами, и выведите это количество.

### Исходные данные

В первой строке дано количество тестов T (1 ≤ T ≤ 10). В следующих T строках перечислены тесты. В каждой из них записаны целые числа n и k через пробел (2 ≤ k ≤ n ≤ 104).

### Результат

Для каждого теста в отдельной строке выведите одно целое число — ответ на задачу.

## Решение

```go
package main

import "fmt"

func main() {
	var t, n, k int
	if _, err := fmt.Scan(&t); err != nil {
		return
	}
	for i := 0; i < t; i++ {
		fmt.Scan(&n, &k)
		res := solve(n, k)
		fmt.Println(res)
	}
}

func solve(n int, k int) int {
	eq := n / k
	rest := n % k
	teams := make([]int, k)
	for i := 0; i < k; i++ {
		if rest > 0 {
			teams[i] = eq + 1
			rest--
		} else {
			teams[i] = eq
		}
	}
	var total int
	for _, team := range teams {
		total += team * (n - team)
	}

	return total / 2
}
```

## Объяснение алгоритма

Наибольшее количество боев состоится в случае, когда участники распределены по командам максимально равномерно. Поэтому сначала заполняем всех по-ровну и оставшихся по одному в команды докидываем. Каждый участник команды сможет вступить бой со всеми, кроме своих товарищей. Получается, что для каждой команды кол-во боев равно `team * (n - team)`. Однако мы каждого учтем 2 раза, поэтому делим на 2.
Время работы алгоритма `O(n)`. По памяти тоже `O(n)`. Но наверное здесь можно обойтись формулами комбинаторики.


# Задача 1296. Гиперпереход

## Условие

Гиперпереход, открытый ещё в начале XXI-го века, и сейчас остаётся основным способом перемещения на расстояния до сотен тысяч парсеков. Но совсем недавно физиками открыто новое явление. Оказывается, длительностью альфа-фазы перехода можно легко управлять. Корабль, находящийся в альфа-фазе перехода, накапливает гравитационный потенциал. Чем больше накопленный гравитационный потенциал корабля, тем меньше энергии потребуется ему на прыжок сквозь пространство. Ваша цель — написать программу, которая позволит кораблю за счёт выбора времени начала альфа-фазы и её длительности накопить максимальный гравитационный потенциал.
В самой грубой модели грави-интенсивность — это последовательность целых чисел pi. Будем считать, что если альфа-фаза началась в момент i и закончилась в момент j, то накопленный в течение альфа-фазы потенциал — это сумма всех чисел, стоящих в последовательности на местах от i до j.

### Исходные данные

В первой строке записано целое число N — длина последовательности, отвечающей за грави-интенсивность (0 ≤ N ≤ 60000). Далее идут N строк, в каждой записано целое число pi (−30000 ≤ pi ≤ 30000).

### Результат

Выведите максимальный гравитационный потенциал, который может накопить корабль в альфа-фазе прыжка. Считается, что потенциал корабля в начальный момент времени равен нулю.

## Решение

```go
package main

import (
	"fmt"
)

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	var n int
	fmt.Scan(&n)

	if n <= 0 {
		fmt.Println(0)
		return
	}

	nums := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&nums[i])
	}

	maxSum, currentSum := 0, 0
	for i := 0; i < n; i++ {
		currentSum = max(nums[i], currentSum+nums[i])
		maxSum = max(maxSum, currentSum)
	}

	fmt.Println(maxSum)
}
```

## Объяснение алгоритма

Используем алгоритм Кадане, который позволяет найти подмассив с максимальной суммой. Создаем 2 переменные с максимальной и текущей суммой. Максимальную сумму обновляем только в случае, если текущая превысила ее значение. Текущую сумму обновляем, если текущий элемент сам по себе больше текущей суммы. Благодаря этому, можно решить задачу за 1 проход => сложность `O(1)`.



# Задача 1726. Кто ходит в гости...


## Условие

Программный комитет школьных соревнований по программированию, проходящих в УрГУ — многочисленная, весёлая и дружная команда. Дружная настолько, что общения в университете им явно не хватает, поэтому они часто ходят друг к другу в гости. Все ребята в программном комитете очень спортивные и ходят только пешком.
Однажды хранитель традиций олимпиадного движения УрГУ подумал, что на пешие прогулки от дома к дому члены программного комитета тратят слишком много времени, которое могли бы вместо этого потратить на придумывание и подготовку задач. Чтобы доказать это, он решил посчитать, какое расстояние в среднем преодолевают члены комитета, когда ходят друг к другу в гости. Хранитель традиций достал карту Екатеринбурга, нашёл на ней дома всех членов программного комитета и выписал их координаты. Но координат оказалось так много, что хранитель не смог справиться с этой задачей самостоятельно и попросил вас помочь ему.
Город Екатеринбург представляет собой прямоугольник со сторонами, ориентированными по сторонам света. Все улицы города идут строго с запада на восток или с севера на юг, проходя через весь город от края до края. Дома всех членов программного комитета расположены строго на пересечении каких-то двух перпендикулярных улиц. Известно, что все члены комитета ходят только по улицам, поскольку идти по тротуару гораздо приятнее, чем по дворовым тропинкам. И, конечно, при переходе от дома к дому они всегда выбирают кратчайший путь. Программный комитет очень дружный, и все его члены ходят в гости ко всем одинаково часто.

### Исходные данные

Первая строка содержит целое число n — количество членов программного комитета (2 ≤ n ≤ 105). В i-й из следующих n строк через пробел записаны целые числа xi, yi — координаты дома i-го члена программного комитета (1 ≤ xi, yi ≤ 106).

### Результат

Выведите среднее расстояние, которое проходит член программного комитета от своего дома до дома своего товарища, округлённое вниз до целых.


## Решение
Решение на `golang` не укладывается по времени, хотя оно верное(
```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	var n int
	fmt.Scan(&n)

	xs := make([]int, n)
	ys := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Scan(&xs[i], &ys[i])
	}

	sort.Ints(xs)
	sort.Ints(ys)
	sum := 0

	for i := 0; i < n; i++ {
		sum += xs[i] * (2*i - n + 1)
		sum += ys[i] * (2*i - n + 1)
	}

	sum *= 2
	walks := n * (n - 1)

	res := sum / walks
	fmt.Println(res)
}
```
Решение на `python` уложилось по времени. Скорее всего из-за сортировки на `C++`

```python
from math import floor

n = int(input())
xs = []
ys = []
for i in range(n):
    x, y = map(int, input().split())
    xs.append(x)
    ys.append(y)
xs.sort()
ys.sort()
sum = 0
for i in range(n):
    sum += xs[i] * (2*i - n + 1)
    sum += ys[i] * (2*i - n + 1)

sum *= 2
walks = n * (n-1)
print(floor(sum/walks))
```

## Объяснение алгоритма
В данном решении используется сортировка координат домов отдельно по X и Y, после чего применяется формула, учитывающая медианное свойство Манхэттенского расстояния. Для каждой координаты вычисляется сумма расстояний от данной точки до всех остальных, используя формулу $\sum |x_i - x_j|$, которая оптимизируется через отсортированные массивы.

Алгоритм имеет сложность $(O(n \log n))$ за счёт сортировки.


# Результаты выполнения на Тимусе

## [Ссылка на папку](https://disk.yandex.ru/d/wmh_uM2-zG-XHA)


# Вывод 

Я узнал название алгоритма Кадане (до этого я его использовал, но не знал точного названия), который использовал для того чтобы сдать ЕГЭ. Вспомнил элементы комбинаторики, но не смог найти математического решения и решил все через циклы и получилось. Также была решена интересная задача с расчетом и сортировкой координат.