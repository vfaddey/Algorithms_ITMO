Студент: Валуев Фаддей Денисович\
ISU: 408352


# Задача 1521. Военные учения 2.

## Условие
В соответствии с этой схемой учения делятся на N раундов, в течение которых N солдат, последовательно пронумерованных от 1 до N, маршируют друг за другом по кругу, т.е. первый следует за вторым, второй за третьим, ..., (N-1)-й за N-м, а N-й за первым. В каждом раунде очередной солдат выбывает из круга и идёт чистить унитазы, а оставшиеся продолжают маршировать. В очередном раунде выбывает солдат, марширующий на K позиций впереди выбывшего на предыдущем раунде. В первом раунде выбывает солдат с номером K.
Разумеется, г-н Шульман не питал никаких надежд на то, что солдаты в состоянии сами определить очерёдность выбывания из круга. «Эти неучи даже траву не могут ровно покрасить», – фыркнул он и отправился за помощью к прапорщику Шкурко.


### Исходные данные
Единственная строка содержит целые числа $N$ $(1 ≤ N ≤ 100000)$ и K $(1 ≤ K ≤ N)$.

### Результат
Вывести через пробел номера солдат в порядке их выбывания из круга.


## Решение

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

static int n;
static int64_t k;
static int *fenw;
static int logn;

static void fenw_add(int i, int v) {
    for (; i <= n; i += i & -i)
        fenw[i] += v;
}

static int fenw_sum(int i) {
    int s = 0;
    for (; i > 0; i -= i & -i)
        s += fenw[i];
    return s;
}

static int fenw_find_kth(int k_th) {
    int pos = 0;
    for (int step = logn; step > 0; step >>= 1) {
        int nxt = pos + step;
        if (nxt <= n && fenw[nxt] < k_th) {
            k_th -= fenw[nxt];
            pos = nxt;
        }
    }
    return pos + 1;
}

int main() {
    if (scanf("%d %lld", &n, &k) != 2) {
        return 0;
    }

    logn = 1;
    while ((logn << 1) <= n) {
        logn <<= 1;
    }

    fenw = malloc((n + 1) * sizeof(int));
    if (!fenw) {
        perror("malloc");
        return 1;
    }
    for (int i = 1; i <= n; i++) {
        fenw[i] = 0;
    }
    for (int i = 1; i <= n; i++) {
        fenw_add(i, 1);
    }

    int remaining = n;
    int64_t current = 0;
    for (int removed = 0; removed < n; removed++) {
        int64_t steps = (k - 1) % remaining;
        current = (current + steps) % remaining;

        int k_th = (int)(current + 1);
        int pos = fenw_find_kth(k_th);

        printf("%d\n", pos);
        fenw_add(pos, -1);


        remaining--;
    }

    free(fenw);
    return 0;
}
```

## Объяснение алгоритма
Алгоритм инициализирует дерево Фенвика размером N, где каждая вершина хранит количество «живых» солдат (изначально 1). Затем для каждого из N раундов с помощью текущей позиции и операции по модулю вычисляется порядковый номер удаляемого солдата в оставшемся круге, после чего методом бинарного поиска по дереву Фенвика (fenw_find_kth) за O(log N) находится его исходный индекс и выполняется вычитание 1 в этом узле. Повторяя эти шаги N раз, получаем полную последовательность выбывания; общая временная сложность — O(N log N), дополнительная память — O(N).


# Задача 1450. Российские газопроводы.

## Условие

Задача
Сеть российских газопроводов представляет собой N перекачивающих станций, некоторые из которых соединены газопроводами. Для каждого из M газопроводов известны номера станций A[i] и B[i], которые он соединяет, и его прибыльность C[i], т.е. то количество долларов, которое будет ежесуточно приносить в виде налогов перекачка газа по этому газопроводу. Каждая пара станций соединена не более чем одним газопроводом.
Сеть была построена советскими инженерами, которые точно знали, что газ поставляется из месторождений Украины в Сибирь, а не наоборот. Поэтому все газопроводы являются однонаправленными, т.е. для каждого газопровода перекачка газа возможна только в направлении из станции с номером A[i] на станцию с номером B[i]. Более того, для любых двух станций X и Y верно, что если возможна перекачка газа из X на Y (возможно, через промежуточные станции), то обратная перекачка из Y на X невозможна. Известно, что газ поступает на начальную станцию с номером S и отгружается потребителям на конечной станции с номером F.
Президент потребовал от Правительства указать маршрут (т.е. линейную последовательность попарно соединённых газопроводами станций) перекачки газа из начальной станции на конечную, причём прибыльность этого маршрута должна быть максимальной. Под прибыльностью маршрута понимается суммарная прибыльность входящих в него газопроводов.
К сожалению, Президент не учёл того факта, что многие газопроводы изначальной сети уже давно прекратили существование, в результате чего может оказаться, что перекачка газа из начальной станции на конечную вообще невозможна...


### Исходные данные
Первая строка содержит целые числа N (2 ≤ N ≤ 500) и M (0 ≤ M ≤ 124750). Каждая из следующих M строк содержит целые числа A[i], B[i] (1 ≤ A[i], B[i] ≤ N) и C[i] (1 ≤ C[i] ≤ 10000) для соответствующего газопровода. Последняя строка содержит целые числа S и F (1 ≤ S, F ≤ N; S ≠ F).

### Результат
Если искомый маршрут существует, выведите его прибыльность. Иначе выведите "No solution".


## Решение

```python
from collections import deque

N, M = map(int, input().split())
adj = [[] for _ in range(N+1)]
indegree = [0] * (N+1)

for _ in range(M):
    u, v, c = map(int, input().split())
    adj[u].append((v, c))
    indegree[v] += 1

S, F = map(int, input().split())
q = deque(i for i in range(1, N+1) if indegree[i] == 0)
topo = []

while q:
    u = q.popleft()
    topo.append(u)
    for v, _ in adj[u]:
        indegree[v] -= 1
        if indegree[v] == 0:
            q.append(v)

NEG_INF = -10**18
dp = [NEG_INF] * (N+1)
dp[S] = 0

for u in topo:
    if dp[u] == NEG_INF:
        continue
    for v, w in adj[u]:
        if dp[u] + w > dp[v]:
            dp[v] = dp[u] + w

if dp[F] == NEG_INF:
    print("No solution")
else:
    print(dp[F])
```

## Объяснение алгоритма
Алгоритм сначала строит топологическую сортировку вершин ориентированного ацикличного графа (ОАГ) методом Кана за время $O(N + M)$. Затем по полученному порядку выполняется динамическое программирование: для каждой вершины u и каждого исходящего ребра $(u→v)$ обновляется максимальная прибыль $dp[v] = max(dp[v], dp[u] + w)$. В конце проверяется достижимость конечной станции $F$: если $dp[F]$ осталось равным $–\infty$, выводится «No solution», иначе — значение $dp[F]$. Общая временная сложность — $O(N + M)$, дополнительная память — $O(N + M)$.



# Задача 1806. Мобильные телеграфы.

## Условие
Каждому бойцу 25-й стрелковой дивизии выдали новейшее средство связи — мобильный телеграф. С его помощью можно отправлять телеграммы командованию и боевым товарищам прямо на поле битвы. К сожалению, конструкция телеграфов ещё далека от совершенства — передавать сообщения можно только между некоторыми парами телеграфов.
Каждому устройству присвоен уникальный номер — строка из десяти десятичных цифр. С телеграфа a можно отправить сообщение на телеграф b только в том случае, если из номера a можно получить номер b, изменив в нём ровно одну цифру либо поменяв в нём две цифры местами. Время передачи сообщения с телеграфа a на телеграф b зависит от длины наибольшего общего префикса их номеров — чем больше его длина, тем быстрее передаётся сообщение.
Во время очередного сражения Анка из своей хорошо замаскированной позиции увидела небольшую группу белых, пытающуюся обойти обороняющихся красноармейцев с тыла. Какое минимальное время понадобится на доставку этой информации от Анки до Чапаева по телеграфу, возможно, с помощью других красноармейцев?


### Исходные данные
В первой строке записано целое число $n (2 ≤ n ≤ 50000)$ — количество бойцов в дивизии. Во второй строке через пробел в порядке невозрастания записаны десять целых чисел в пределах от 1 до 10000 — время передачи сообщения с одного телеграфа на другой при длине общего префикса их номеров, равной нулю, единице, двум, …, девяти. Далее идут n строк, содержащие номера телеграфов, выданных бойцам дивизии. Номер телеграфа Анки указан первым, а номер телеграфа Чапаева — последним. Все номера телеграфов попарно различны.

### Результат
Если передать Чапаеву сообщение нельзя, выведите в единственной строке «-1». В противном случае в первой строке выведите минимальное время, за которое можно доставить сообщение. Во второй строке выведите количество бойцов, которые поучаствуют в его доставке, а в третьей строке выведите через пробел их номера в порядке от Анки к Чапаеву. Бойцы 25-й дивизии занумерованы числами от 1 до n в том порядке, в котором описаны номера их мобильных телеграфов на входе. Если существует несколько способов передать сообщение за минимальное время, выведите любой из них.


## Решение

```go
package main

import (
	"bufio"
	"container/heap"
	"fmt"
	"os"
)

type Item struct {
	node int
	dist int64
}


type PriorityQueue []Item

func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool {
	return pq[i].dist < pq[j].dist
}
func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
}
func (pq *PriorityQueue) Push(x interface{}) {
	*pq = append(*pq, x.(Item))
}
func (pq *PriorityQueue) Pop() interface{} {
	n := len(*pq)
	item := (*pq)[n-1]
	*pq = (*pq)[:n-1]
	return item
}

func main() {
	reader := bufio.NewReader(os.Stdin)
	var n int
	fmt.Fscan(reader, &n)

	T := make([]int64, 10)
	for i := 0; i < 10; i++ {
		fmt.Fscan(reader, &T[i])
	}

	nums := make([]string, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &nums[i])
	}

	src, dst := 0, n-1

	// Индексирование номеров
	idx := make(map[string]int, n)
	for i, s := range nums {
		idx[s] = i
	}

	const INF = int64(1e18)
	dist := make([]int64, n)
	prev := make([]int, n)
	for i := range dist {
		dist[i] = INF
		prev[i] = -1
	}
	dist[src] = 0

	// Инициализация очереди
	pq := &PriorityQueue{}
	heap.Init(pq)
	heap.Push(pq, Item{node: src, dist: 0})

	for pq.Len() > 0 {
		item := heap.Pop(pq).(Item)
		u, d := item.node, item.dist
		if d != dist[u] {
			continue
		}
		if u == dst {
			break
		}
		s := nums[u]
		
		sBytes := []byte(s)
		for i := 0; i < 10; i++ {
			orig := sBytes[i]
			for c := byte('0'); c <= byte('9'); c++ {
				if c == orig {
					continue
				}
				sBytes[i] = c
				if v, ok := idx[string(sBytes)]; ok {
					newDist := d + T[i]
					if newDist < dist[v] {
						dist[v] = newDist
						prev[v] = u
						heap.Push(pq, Item{node: v, dist: newDist})
					}
				}
			}
			sBytes[i] = orig
		}

		for i := 0; i < 10; i++ {
			for j := i + 1; j < 10; j++ {
				if sBytes[i] == sBytes[j] {
					continue
				}
				sBytes[i], sBytes[j] = sBytes[j], sBytes[i]
				if v, ok := idx[string(sBytes)]; ok {
					newDist := d + T[i]
					if newDist < dist[v] {
						dist[v] = newDist
						prev[v] = u
						heap.Push(pq, Item{node: v, dist: newDist})
					}
				}
				sBytes[i], sBytes[j] = sBytes[j], sBytes[i]
			}
		}
	}

	if dist[dst] == INF {
		fmt.Println(-1)
		return
	}

	path := []int{}
	for cur := dst; cur != -1; cur = prev[cur] {
		path = append(path, cur+1)
	}
	reverse(path)

	fmt.Println(dist[dst])
	fmt.Println(len(path))
	for i, v := range path {
		if i > 0 {
			fmt.Print(" ")
		}
		fmt.Print(v)
	}
	fmt.Println()
}

func reverse(a []int) {
	for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
		a[i], a[j] = a[j], a[i]
	}
}
```

## Объяснение алгоритма

Алгоритм моделирует устройства как вершины взвешенного графа: из каждой вершины u генерируются соседи v путём замены одной цифры или обмена двух цифр в номере u, причём вес ребра равен $T[i]$, где $i$ — длина общего префикса номеров до первой разницы. Используется хэш-таблица idx для мгновенного поиска номера по строке, а массивы dist и prev вместе с приоритетной очередью реализуют алгоритм Дейкстры для вычисления кратчайших путей от Анки до Чапаева. Если после обхода dist[dst] остаётся бесконечным, выводится «-1», иначе по цепочке prev восстанавливается и выводится оптимальный маршрут и его суммарное время. Временная сложность алгоритма — $O(n \log n)$ (из каждой из n вершин проверяется O(1)≈135 соседей, а операции с кучей требуют log n), дополнительная память — $O(n)$.


# Результаты выполнения на Тимусе

## [Ссылка на папку](https://disk.yandex.ru/d/vsP7Zg1Kcvlspg)
