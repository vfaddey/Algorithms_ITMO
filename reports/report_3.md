# Задача 1160. Сеть. 

## Условие задачи.

Эндрю хочет соединить **N** концентраторов в одну связную сеть с помощью кабелей. Каждый концентратор должен быть доступен из любого другого (возможно, через промежуточные узлы). Из всех возможных планов подключения требуется выбрать такой, при котором **максимальная длина используемого кабеля минимальна**. Не все пары концентраторов можно соединить (из‑за ограничений совместимости и геометрии здания), но гарантируется, что существует хотя бы один способ связать все концентраторы.

### Входные и исходные данные

- **Вход**  
  Первая строка содержит два целых числа **N** (2 ≤ N ≤ 1000) и **M** (1 ≤ M ≤ 15000) — количество концентраторов и число возможных соединений.  
  Следующие **M** строк содержат по три целых числа: номера концентраторов **u, v** (1 ≤ u, v ≤ N, u ≠ v) и длину кабеля **w** (1 ≤ w ≤ 10^6).

- **Выход**
    1. В первой строке — минимально возможная максимальная длина кабеля в выбранном плане.
    2. Во второй строке — число используемых кабелей **P** (оно будет равно N−1 для связного дерева).
    3. Далее **P** строк по две цифры — номера концентраторов, которые соединяются каждым кабелем.

## Код решения

```go
package main

import (
	"fmt"
	"sort"
)

type Edge struct { u, v, w int }

type DSU struct { parent []int }

func NewDSU(n int) *DSU {
	parent := make([]int, n+1)
	for i := 1; i <= n; i++ {
		parent[i] = i
	}
	return &DSU{parent}
}

func (d *DSU) Find(x int) int {
	if d.parent[x] != x {
		d.parent[x] = d.Find(d.parent[x])
	}
	return d.parent[x]
}

func (d *DSU) Union(x, y int) {
	px, py := d.Find(x), d.Find(y)
	if px != py {
		d.parent[px] = py
	}
}

func main() {
	var N, M int
	fmt.Scan(&N, &M)

	edges := make([]Edge, M)
	for i := 0; i < M; i++ {
		fmt.Scan(&edges[i].u, &edges[i].v, &edges[i].w)
	}

	sort.Slice(edges, func(i, j int) bool {
		return edges[i].w < edges[j].w
	})

	dsu := NewDSU(N)
	mstEdges := make([]Edge, 0, N-1)
	maxWeight := 0

	for _, e := range edges {
		if dsu.Find(e.u) != dsu.Find(e.v) {
			dsu.Union(e.u, e.v)
			mstEdges = append(mstEdges, e)
			if e.w > maxWeight {
				maxWeight = e.w
			}
		}
		if len(mstEdges) == N-1 {
			break
		}
	}

	fmt.Println(maxWeight)
	fmt.Println(len(mstEdges))
	for _, e := range mstEdges {
		fmt.Println(e.u, e.v)
	}
}
```

## Объяснение алгоритма

Мы строим **минимальное остовное дерево (MST)** алгоритмом Краскала: сортируем все возможные соединения по длине кабеля и по очереди добавляем самые короткие, если они не создают цикл (с помощью структуры Union‑Find). В итоге получаем связную сеть из N−1 кабеля, в которой **максимальная длина кабеля минимальна** среди всех возможных вариантов. 






# Задача 1604. В Стране Дураков.

## Условие задачи

У главного бульдог‑полицейского есть набор дорожных знаков с ограничениями скорости разных типов (k типов, каждый тип i встречается ni раз). Он хочет разместить их вдоль трассы так, чтобы водитель менял скорость как можно чаще (то есть ни два соседних знака не должны иметь одинаковое ограничение). Если несколько решений возможны — можно вывести любое.

---

### Входные и выходные данные

**Вход:**
- Первая строка: целое k (1 ≤ k ≤ 10000) — число разных типов знаков.
- Вторая строка: k целых чисел n₁, n₂, …, n_k (∑ ni ≤ 10000) — сколько знаков каждого типа.

**Выход:**
- Последовательность из n₁ + … + n_k чисел (каждое от 1 до k) — порядок размещения знаков.

---

## Код решения

```go
package main

import (
	"container/heap"
	"fmt"
)

type Item struct {
	typeID int
	count  int
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int           { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i].count > pq[j].count }
func (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }
func (pq *PriorityQueue) Push(x interface{}) {
	*pq = append(*pq, x.(*Item))
}
func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	item := old[len(old)-1]
	*pq = old[:len(old)-1]
	return item
}

func solve_task(k int, counts []int) []int {
	pq := make(PriorityQueue, 0)
	for i := range counts {
		if counts[i] > 0 {
			heap.Push(&pq, &Item{typeID: i + 1, count: counts[i]})
		}
	}

	var result []int
	prev := 0

	for pq.Len() > 0 {
		first := heap.Pop(&pq).(*Item)
		if first.typeID != prev {
			result = append(result, first.typeID)
			first.count--
			if first.count > 0 {
				heap.Push(&pq, first)
			}
			prev = first.typeID
		} else {
			second := heap.Pop(&pq).(*Item)
			result = append(result, second.typeID)
			second.count--
			if second.count > 0 {
				heap.Push(&pq, second)
			}
			heap.Push(&pq, first)
			prev = second.typeID
		}
	}
	return result
}

func main() {
	var k int
	fmt.Scan(&k)
	counts := make([]int, k)
	for i := range counts {
		fmt.Scan(&counts[i])
	}
	seq := solve_task(k, counts)
	for i, id := range seq {
		if i > 0 { fmt.Print(" ") }
		fmt.Print(id)
	}
	fmt.Println()
}
```


## Объяснение решения

Мы используем **жадный алгоритм с max‑heap (priority queue)**, чтобы никогда не ставить подряд два одинаковых знака:

1. Помещаем в кучу все типы знаков с их текущим количеством (больше → выше приоритет).
2. На каждом шаге извлекаем самый частый тип (`first`).
    - Если он отличается от предыдущего добавленного — добавляем его в результат, уменьшаем счётчик и возвращаем в кучу (если остались).
    - Если совпадает с предыдущим — извлекаем второй по частоте (`second`), добавляем его, уменьшаем счётчик и возвращаем оба обратно (если остались).
3. Повторяем до тех пор, пока все знаки не будут размещены.

### Сложность

- **Время:** O(n log k), где n = ∑ni — общее число знаков, k — число типов (heap‑операции выполняются за O(log k) для каждого из n шагов).
- **Память:** O(k + n) — для хранения кучи и итоговой последовательности.  



# Задача 1494. Монобильярд.

## Условие задачи

Чичиков утверждает, что закатил шары с номерами 1, 2, …, N в лузу именно в этом порядке. Ревизор при этом несколько раз подходил к столу и забирал из лузы верхний (последний закатившийся) шар. В результате ревизор извлёк все N шаров в некотором порядке. Нужно проверить, мог ли этот порядок извлечения соответствовать правильному порядку закатывания (1→2→…→N). Если нет — вывести **Cheater**, иначе — **Not a proof**.

---

### Входные данные

- Первая строка: целое число N (1 ≤ N ≤ 100 000) — число шаров.
- Следующие N строк содержат по одному целому числу — номера шаров в порядке их извлечения ревизором.

### Выходные данные

- **Cheater**, если последовательность извлечения невозможна при правильном порядке закатывания.
- **Not a proof**, если последовательность извлечения могла получиться при закатывании шаров в порядке 1…N.

---

## Код решения (Go)

```go
package main

import "fmt"

func main() {
    var n int
    fmt.Scan(&n)

    balls := make([]int, n)
    for i := 0; i < n; i++ {
        fmt.Scan(&balls[i])
    }

    stack := make([]int, 0)
    next := 1

    for _, ball := range balls {
        for next <= n && (len(stack) == 0 || stack[len(stack)-1] != ball) {
            stack = append(stack, next)
            next++
        }
        if len(stack) > 0 && stack[len(stack)-1] == ball {
            stack = stack[:len(stack)-1]
        } else {
            fmt.Println("Cheater")
            return
        }
    }
    fmt.Println("Not a proof")
}
```


## Объяснение решения

Мы моделируем процесс закатывания шаров как **стек**: новые шары (номера от 1 до N) кладутся сверху, а ревизор всегда забирает верхний шар. Чтобы проверить, мог ли Чичиков закатывать шары в правильном порядке (1,2,…,N), достаточно симулировать:

1. Идём по последовательности извлечённых шаров `balls`.
2. Если вершина стека не равна текущему ожидаемому шарику из `balls`, добавляем в стек следующие номера (от `next` до тех пор, пока верхний элемент не совпадёт с нужным или не достигнем N).
3. Если верхушка стека совпадает с текущим извлечённым шаром — снимаем её; иначе — выводим **Cheater** и завершаем.
4. Если все шары успешно сняты — выводим **Not a proof**.

### Временная сложность

- Каждый шар один раз помещается в стек и один раз из него извлекается → **O(N)** операций.
- Все действия со стеком выполняются за O(1).

Итого **O(N)** по времени и **O(N)** по памяти.



# Результаты выполнения на Тимусе

## [Ссылка на папку](https://disk.yandex.ru/d/IXKdRoGAS-OwZw)

# Вывод

В первой задаче я понял, что построение минимального остовного дерева (алгоритм Краскала + DSU) позволяет минимизировать максимальную длину кабеля при сохранении связности сети.  
Во второй задаче я увидел, как при помощи max‑heap (priority queue) и жадного выбора самых частых типов знаков можно гарантировать отсутствие одинаковых соседних элементов в последовательности.  
В третьей задаче стало ясно, что моделирование процесса извлечения шаров через стек — простой и эффективный способ проверить, соответствует ли порядок извлечения правильному порядку закатывания.

